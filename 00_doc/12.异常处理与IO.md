# 12. 异常处理与IO

## 12.6 何时使用异常

一般错误需要被方法的调用者处理的时候，方法应该抛出一个异常。

将错误处理代码从正常的程序设计任务中分离出来，可以使得程序更加容易阅读、更加容易修改。

异常出现在方法中，一般来说一个项目中多个类都会发生的异常应该考虑作为一种异常类。

不要在 try catch 中处理一些可以预料的异常，应该是处理一些无法预料且复杂的异常。



## 12.7 重新抛出异常

如果你的异常处理无妨对这个异常进行有效处理，你依旧可以抛出这个异常然后让其他调用者来处理。

```java
try{
    statements;
}
catch(Exception ex){
    perform operations before exists;
    throw ex;
}
```



## 12.8 链式异常

和其他异常一起抛出一个异常，构成一个链式异常。

和重新抛出异常概念一样，不过有时候你还希望同原始异常一同抛出一个新的异常（带有附加信息），称之为链式异常（chained exception）

其实就是一个方法1在本身自己就会抛出异常，然后它又调用了也能抛出异常的方法2。那么任何一个调用者在调用方法1的时候可以获得两个意外。

```java
public class ChainedExceptionDemo {

    public static void main(String[] args) {
        try {
            method1();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    private static void method1() throws Exception {
        try {
            method2();
        } catch (Exception ex) {
            throw new Exception("New info from method1", ex);
        }
    }

    private static void method2() throws Exception {
        throw new Exception("New info from method2");
    }
}
```



**练习12.24**

如果第16行被下面一句锁代替，会输出什么？

`throw new Exception(“New Info from method 1”)`

就是只会显示method1的错误提示，并不会把method2中的打印出来。



## 12.9 创建自定义类

通过派生 `java.lang.Exception` 来定义一个自定义的异常类。仅在无法描述问题的时候使用。

创建异常：

- 创建一个异常类，继承与Exception类
- 然后创建该类的构造器方法，在构造方法中调用 super 父类构造方法，并传入参数，参数就是你的错误信息
- 调用方在方法中根据需求创建一个自定义异常类，然后调用类上抛出异常

程序清单12-7中，半径为负，`setRadius` 方法会抛出一个异常。假设希望吧这个半径 传递给处理器，这种情况通常需要自定义异常类。

**程序清单12-10**

```java
public class example.InvalidRadiusException extends Exception {

    private double radius;

    public example.InvalidRadiusException(double radius) {
        super("Invalid Radius"+radius);
        this.radius = radius;
    }

    public double getRadius(){
        return radius;
    }
}

```

程序清单12-11 使用自定义Exception

```java
public class example.TestCircleWithCustomizedException {

    public static void main(String[] args) {

        try {
            example.CircleWithCustomizedException circle1 = new example.CircleWithCustomizedException(2.0);
            example.CircleWithCustomizedException circle2 = new example.CircleWithCustomizedException(8.0);
            example.CircleWithCustomizedException circle3 = new example.CircleWithCustomizedException(-1.0);
        } catch (example.InvalidRadiusException e) {
            e.printStackTrace();
        }finally {
            System.out.println(example.CircleWithCustomizedException.getNumberOfObjects());
        }

    }
}

class example.CircleWithCustomizedException {

    private double rad;
    private static int numberOfObjects;

    public example.CircleWithCustomizedException() throws example.InvalidRadiusException {
        this(1.0);
    }

    public example.CircleWithCustomizedException(double rad) throws example.InvalidRadiusException {
        setRadius(rad);
        numberOfObjects++;
    }

    private void setRadius(double newRad) throws example.InvalidRadiusException {

        if (newRad <= 0) {
            throw new example.InvalidRadiusException(newRad);
        }else
            rad = newRad;
    }

    public double calArea(double rad) {
        return rad * rad * Math.PI;
    }

    public double getRad() {
        return rad;
    }

    public static int getNumberOfObjects() {
        return numberOfObjects;
    }
}
```



**练习12.26**

假定`setRadius`会抛出程序清单12-10中定义的`InvalidRadiusException`，那么运行下面的程序会显示什么？



